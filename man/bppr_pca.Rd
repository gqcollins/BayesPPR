% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bppr_pca.R
\name{bppr_pca}
\alias{bppr_pca}
\title{BayesPPR for Multivariate Response}
\usage{
bppr_pca(
  X,
  Y,
  n_pc = NULL,
  prop_var = 0.99,
  n_cores = 1,
  par_type = "fork",
  n_ridge_mean = 10,
  n_ridge_max = NULL,
  n_act_max = NULL,
  df_spline = 4,
  prob_relu = 2/3,
  prior_coefs = "zs",
  shape_var_coefs = NULL,
  rate_var_coefs = NULL,
  n_dat_min = NULL,
  scale_proj_dir_prop = NULL,
  adapt_act_feat = TRUE,
  w_n_act = NULL,
  w_feat = NULL,
  n_post = 1000,
  n_burn = 9000,
  n_adapt = 0,
  n_thin = 1,
  print_every = NULL,
  bppr_init_list = NULL
)
}
\arguments{
\item{X}{a data frame or matrix of predictors. Categorical features should be coded as numeric.}

\item{Y}{a data frame or matrix of responses, with columns representing different dimensions of the response.}

\item{n_pc}{number of principle components to be used in pca approximation of Y.}

\item{prop_var}{proportion of variance to be explained by the first \code{n_pc} principle components. Used for automatic selection of \code{n_pc} if \code{is.null(n_pc)}.}

\item{n_cores}{number of cores the user desired to utilize for parallel computation.}

\item{par_type}{a character variable dicatating the type of parallel computation to be performed. Supported values include \code{"fork"}, which uses \code{parallel::mclapply()}, and \code{"socket"}, which uses \code{parallel::parLapply()}.}

\item{n_ridge_mean}{mean for Poisson prior on the number of ridge functions.}

\item{n_ridge_max}{maximum number of ridge functions allowed in the model. Used to avoid memory overload. Defaults to 150 unless the number of observed responses is small.}

\item{n_act_max}{maximum number of active variables in any given ridge function. Defaults to 3 unless categorical features are detected, in which case the default is larger.}

\item{df_spline}{degrees of freedom for spline basis. Stability should be examined for anything other than 4.}

\item{prob_relu}{prior probability that any given ridge function uses a relu transformation.}

\item{prior_coefs}{form of the prior distribution for the basis coefficients. Default is \code{"zs"} for the Zellner-Siow prior. The other option is \code{"flat"}, which is an improper prior.}

\item{shape_var_coefs}{shape for IG prior on the variance of the basis function coefficients. Default is for the Zellner-Siow prior. For the flat, improper prior, \code{shape_var_coefs} is ignored.}

\item{rate_var_coefs}{rate for IG prior on the variance of the basis function coefficients. Default is for the Zellner-Siow prior. For the flat, improper prior, \code{rate_var_coefs} is ignored.}

\item{n_dat_min}{minimum number of observed non-zero datapoints in a ridge function. Defaults to 20 or 0.1 times the number of observations, whichever is smaller.}

\item{scale_proj_dir_prop}{scale parameter for generating proposed projection directions. Should be in (0, 1); default is about 0.002.}

\item{adapt_act_feat}{logical; if \code{TRUE}, use adaptive proposal for feature index sets and number of active features.}

\item{w_n_act}{vector of weights for number of active variables in a ridge function, used in generating proposed basis functions. If \code{adapt_act_feat == FALSE}, it is also used for the prior distribution. Default is \code{rep(1, n_act_max)}.}

\item{w_feat}{vector of weights for feature indices used in a ridge function, used in generating proposed basis functions. If \code{adapt_act_feat == FALSE}, it is also used for the prior distribution. Default is \code{rep(1, ncol(X))}.}

\item{n_post}{number of posterior draws to obtain from the Markov chain after burn-in.}

\item{n_burn}{number of draws to burn before obtaining \code{n_post} draws for inference. If \code{prior_coefs == "flat"} then these are absorbed into the adapt phase.}

\item{n_adapt}{number of adaptive MCMC iterations to perform before burn-in. Skips sampling basis coefficients and residual variance to save time.}

\item{n_thin}{keep every n_thin posterior draws after burn-in.}

\item{print_every}{print the iteration number every print_every iterations. Use \code{print_every = 0} to silence.}

\item{bppr_init_list}{list of length \code{n_pc}, each element containing a list initial values for the Markov chain. Used by \link{bppr_resume}.}
}
\value{
An object of class \code{"bppr_pca"}. Predictions can be obtained by passing the entire object to the \code{predict.bppr_pca} function.
}
\description{
Fits a BayesPPR model to multivariate response using RJMCMC. Can handle categorical features.
}
\details{
Explores BayesPPR model space using RJMCMC. The BayesPPR model has \deqn{y = f(x) + \epsilon,  ~~\epsilon \sim N(0,\sigma^2)} \deqn{f(x) = \beta_0 + \sum_{j=1}^M \beta_j B_j(x)} and \eqn{B_j(x)} is a natural spline basis expansion. We use priors \deqn{\beta \sim N(0,\sigma^2/\tau (B'B)^{-1})} \deqn{M \sim Poisson(\lambda)} as well as the hyper-prior on the variance \eqn{\tau} of the coefficients \eqn{\beta} mentioned in the arguments above.
}
\examples{
# See examples in bppr documentation.

}
\seealso{
\link{predict.bppr_pca} for prediction.
}
\keyword{analysis}
\keyword{component}
\keyword{nonparametric}
\keyword{principle}
\keyword{projection}
\keyword{pursuit}
\keyword{regression}
\keyword{splines}
